# 其他题

> ## 1. 为什么一定要设一个主键

    InnoDB会为没设置主键的表默认设置一个自增主键

> ## 2. 主键为什么不需要有业务含义

    1. 业务会变，如果业务改变导致主键变更，那么数据在磁盘上的储存位置也会改变，有可能引发页分裂，产生空间碎片
    2. 具有业务意义的主键可能是无法自增的，这时候的插入操作会造成大量的随机I/O

> ## 3. 为什么枚举字段不建议使用ENUM

    1. 枚举在数据库中保存的是对应的整数值，必须进行查找才能转换为字符串，此时会有一定的开销
    2. 枚举的字符串列是固定的，添加或者删除枚举必须ALTER TABLE
    3. 如果一定要使用枚举，建议之后只做追加，使用ALTER TABLE语句

> ## 4. 货币应该使用什么类型保存

    1. 如果单位是分，可以使用Int或者BigInt，如果需要保存精度，可以使用Decimal
    2. 如果精度要求不高的，建议使用Float，因为CPU可以直接处理Float或者Double，而Decimal是Mysql内部实现的精度处理，因此在性能上，使用Float或者Double要略优于Decimal

> ## 5. 时间字段应该使用什么类型

    1. 时间字段可以使用DateTime或者TimeStamp
    2. DateTime与时区无关，可以记录从1001年到9999年，精度为秒
    3. TimeStamp是依赖时区的，而且能够记录的最大值是2038-01-19
    4. 考虑到TimeStamp的时间限制问题，也可以使用BigInt作为记录时间的手段

> ## 6. 为什么不建议使用BLOB和TEXT

    1. MySQL对于BLOB和TEXT适当做独立对象处理的，当BLOB或者TEXT中的值过长时，InnoDB会使用专门的区域来存储字段的值，而在字段中值存储指针，指向数值的存储地址
    2. 在查询时，由于Memmory引擎不支持BLOB和TEXT，因此在需要使用临时表时，无法使用内存临时表，只能使用磁盘临时表，性能损耗严重
    3. 排序也有跟第2点相同的问题

> ## 7. 字段为什么要定义为NOT NULL

    1. MySQL对于可为NULL的列比较难优化
    2. 可为NULL的列在建立索引时，需要更多的空间，来保存是否为空
    3. 在MYISAM引擎中，可为NULL的列甚至还可能导致固定大小的索引变成可变大小的索引

> ## 8. MySQL常用的引擎

    1. InnoDB
    2. MYISAM
    3. Memmory
    4. Achieve
    5. Maria
    6. NDB

> ## 9. 往MySQL中插入十条数据，主键自增，此时删除id为8、9和10的三条记录，然后重启数据库，再新插入一条，那么id是8还是11

    1. 如果是InnoDB，自增id的最大值缓存在内存中，此时重启，相当于OPTIMIZE TABLE，新插入的id是8
    2. 如果是MyISAM，自增id的最大值存在文件中，因此重启后最大值仍然是10，新插入的id是11
